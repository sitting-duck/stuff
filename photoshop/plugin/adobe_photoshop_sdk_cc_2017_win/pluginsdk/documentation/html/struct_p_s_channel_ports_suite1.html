<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<!--
/*
    Copyright 2005-2006 Adobe Systems Incorporated
    Distributed under the MIT License (see accompanying file LICENSE_1_0_0.txt
    or a copy at http://opensource.adobe.com/licenses.html)
*/
Some files are held under additional license. Please see "licenses.html" for more information.
-->

<head>
    <TITLE>Adobe Photoshop SDK: PSChannelPortsSuite1 Struct Reference</TITLE>
    <META HTTP-EQUIV="content-type" CONTENT="text/html;charset=ISO-8859-1"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="basic.css"/>
    <STYLE TYPE="text/css" MEDIA="all"><!--
        @import url("modern.css");
    --></STYLE>
    <LINK TYPE="text/css" REL="stylesheet" HREF="print.css" MEDIA="print"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="mainnav.css"/>
    <LINK TYPE="text/css" REL="stylesheet" HREF="stlab.css"/>
	<LINK TYPE="text/css" REL="stylesheet" HREF="adobetabs.css"/>
<!-- 
    <LINK REL="alternate" TITLE="opensource.adobe.com RSS" HREF="http://sourceforge.net/export/rss2_projnews.php?group_id=132417&amp;rss_fulltext=1" TYPE="application/rss+xml"/>
-->
</HEAD>

<body bgcolor="white">

<div id="mainnav" width="100%">
<table width="100%" border="0"><tr><td width="50%">
<a title="Adobe Systems home page" href="http://www.adobe.com/" tabindex="2"><img src="./images/logo.gif" alt="Adobe Systems, Inc." height="80" width="150"/></a>
</td><td align="right" valign="top">
<a href="index.html" class="el" target="_top"><font size="+2" color="black">Adobe Photoshop SDK</font></a><br/>
<!--
<a href="http://opensource.adobe.com" class="el" target="_top"><font size="-2" color="black">opensource.adobe.com</font></a>
-->
</td></tr></table>

</div>
<br/>
<table border="0" cellspacing="0" cellpadding="0" width="100%">
<tr><td width="10" nowrap="1"> </td>
<td valign="top">
    <table border="0" bgcolor=#ededed cellpadding="5">
    <tr><td nowrap="1">
        <h3 class="navbar">Getting Started</h3>
        <ul>
            <li><a href="ProgrammersGuideIntro.html">Home</a></li>
            <li><a href="index.html">New for Creative Cloud -- CC 2017</a></li>
	        <li><a href="SixtyFourMacintosh.html">Making 64 bit plug-ins for Macintosh</a></li>
	        <li><a href="SixtyFour.html">Making 64 bit plug-ins for Windows</a></li>
            <li><a href="faqs.html">Frequently Asked Questions</a></li>
            <li><a href="tutorialsexamples.html">Tutorials and Examples</a></li>
			<li><a href="DeveloperResources.html">Developer Resources</a></li>
        </ul>
        <h3 class="navbar">SDK API Reference</h3>
        <ul>
			<li><a href="annotated.html">Data Structure List</a></li>
		    <li><a href="classes.html">Data Structure Index</a></li>
			<li><a href="functions.html">Member Index</a></li>
			<li><a href="files.html">File List</a></li>
		    <li><a href="globals.html">File Member Index</a></li>
        </ul>
        <h3 class="navbar">SDK API Features</h3>
        <ul>
            <li><a href="rgcallbacks.html">Callbacks</a></li>
			<li><a href="pluginmodules.html">Plug-in Modules</a></li>
		    <li><a href="memorymanagement.html">Memory Management</a></li>
			<li><a href="resourcemanagement.html">Resource Management</a></li>
			<li><a href="pixelmanagement.html">Pixel Management</a></li>
			<li><a href="colormanagement.html">Color Management</a></li>
			<li><a href="automation.html">Actions and Automation</a></li>
			<li><a href="filehandling.html">File Handling</a></li>
        </ul>
<!--  Moved to link under "Other Documentation"
        <h3 class="navbar">Progammer's Guide</h3>
        <ul>
            <li><a href="PGPlugInBasics.html">Plug-in Basics</a></li>
            <li><a href="PGPlugInTypes.html">Plug-in Types</a></li>
            <li><a href="PGPlugInInterface.html">Plug-in Interface</a></li>
            <li><a href="PGMemoryMgmtStrategies.html">Memory Management Strategies</a></li>
            <li><a href="PGMacOSPlugins.html">Creating Mac OS Plug-ins</a></li>
            <li><a href="PGWinPlugins.html">Creating Windows Plug-ins</a></li>
            <li><a href="PGCallbacks.html">Callbacks and Callback Suites</a></li>
            <li><a href="PGWritingPlugins.html">Writing Plug-ins</a></li>
			<li><a href="PGScriptingPlugins.html">Scripting Plug-ins</a>
		    <li><a href="pgpiplresources.html">Creating PiPL Resources</a></li>
		    <li><a href="pgsamplecode.html">Sample Code</a></li>
		    <li><a href="glossary.html">Glossary of Acronyms</a></li>
        </ul>
-->
        <h3 class="navbar">Other Documentation</h3>
        <ul>
          <li><a href="ProgrammersGuideMain.html">SDK Programmer's Guide</a></li>
		      <li><a href="../PICA.pdf">Adobe PICA API</a>
        </ul>
<!--  Moved to Link under "Getting Started".
        <h3 class="navbar">Developer Resources</h3>
        <ul>
			<li><a href="http://partners.adobe.com/public/developer/photoshop/devcenter.html">Adobe Photoshop Developer Center</a>
            <li><a href="mailinglistandforum.html">Suppport</a></li>
            <li><a href="technicalnotes.html">Technical Notes</a></li>
            <li><a href="license.html">SDK License Agreements</a></li>
        </ul>
-->
    </td></tr>
    </table>
</td>

<td width="10" nowrap="1"> </td>
<td width="100%" valign="top">

<!-- End Header -->

<!-- Generated by Doxygen 1.4.7-20061004 -->
<h1>PSChannelPortsSuite1 Struct Reference<br>
<small>
[<a class="el" href="group___pica_channel_ports_suite.html">Channel Ports Suite Callbacks</a>]</small>
</h1><!-- doxytag: class="PSChannelPortsSuite1" -->The set of routines available in the Channel Ports Suite.  
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="_p_i_channel_ports_suite_8h-source.html">PIChannelPortsSuite.h</a>&gt;</code>
<p>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Data Fields</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#eae2b1855bce31f672578850e0073ec9">CountLevels</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 *count)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines the number levels the port has.  <a href="#eae2b1855bce31f672578850e0073ec9"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#76391d8f9d248932f3e6502547d93283">GetDepth</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, int32 *depth)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the pixel depth at a given level.  <a href="#76391d8f9d248932f3e6502547d93283"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#8c59ec11ad199dab11e9e9a20755b824">GetDataBounds</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, <a class="el" href="struct_v_rect.html">VRect</a> *bounds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the bounds for the pixel data at a given level.  <a href="#8c59ec11ad199dab11e9e9a20755b824"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#d3e94d1df452fa96c0e24e3385766a0d">GetWriteLimit</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, <a class="el" href="struct_v_rect.html">VRect</a> *writeBounds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the bounds to which we can write at a given level.  <a href="#d3e94d1df452fa96c0e24e3385766a0d"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#8f6080d2425a78828a100ea6f4ce4442">GetTilingGrid</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, <a class="el" href="struct_v_point.html">VPoint</a> *tileOrigin, <a class="el" href="struct_v_point.html">VPoint</a> *tileSize)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the tiling information at a given level.  <a href="#8f6080d2425a78828a100ea6f4ce4442"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#4f071d68dc7b36908af4c8e80adee487">GetSupportRect</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, const <a class="el" href="struct_v_rect.html">VRect</a> *bounds, int32 *supportLevel, <a class="el" href="struct_v_rect.html">VRect</a> *supportBounds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Finds the rectangle used as the downsample source for a particular level in the pyramid.  <a href="#4f071d68dc7b36908af4c8e80adee487"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#ab47ec066e6c007b7c3487c347e37896">GetDependentRect</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 sourceLevel, const <a class="el" href="struct_v_rect.html">VRect</a> *sourceBounds, int32 dependentLevel, <a class="el" href="struct_v_rect.html">VRect</a> *dependentBounds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Gets the dependent rectangle at a particular level.  <a href="#ab47ec066e6c007b7c3487c347e37896"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#b8a938423b8e1e901d864e709f85f9a3">CanRead</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, Boolean *canRead)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the plug-in can read from the port.  <a href="#b8a938423b8e1e901d864e709f85f9a3"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#41882dab359c78bf51a5a9a0105b4c68">CanWrite</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, Boolean *canWrite)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines if the plug-in can write to the port.  <a href="#41882dab359c78bf51a5a9a0105b4c68"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#14b738488fe314ac3001251e40a3f8f5">ReadPixelsFromLevel</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, <a class="el" href="struct_v_rect.html">VRect</a> *bounds, const <a class="el" href="struct_pixel_memory_desc.html">PixelMemoryDesc</a> *destination)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a given rectangle (tile) of pixels from a given level of the port.  <a href="#14b738488fe314ac3001251e40a3f8f5"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#c91b7ae935aae2c75ef817ad5d0b8589">WritePixelsToBaseLevel</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, <a class="el" href="struct_v_rect.html">VRect</a> *bounds, const <a class="el" href="struct_pixel_memory_desc.html">PixelMemoryDesc</a> *source)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Writes a rectangle (tile) of pixels to a level in the pyramid.  <a href="#c91b7ae935aae2c75ef817ad5d0b8589"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#4998f7a5db9c601c29c3e9322be082b1">ReadScaledPixels</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, <a class="el" href="struct_v_rect.html">VRect</a> *readRect, const <a class="el" href="struct_p_s_scaling.html">PSScaling</a> *scaling, const <a class="el" href="struct_pixel_memory_desc.html">PixelMemoryDesc</a> *destination)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Reads a given rectangle (tile) of scaled data from the pyramid provided in the port.  <a href="#4998f7a5db9c601c29c3e9322be082b1"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#8351f58591537a4ddc95dc81a5c0b771">FindSourceForScaledRead</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, const <a class="el" href="struct_v_rect.html">VRect</a> *readRect, const <a class="el" href="struct_p_s_scaling.html">PSScaling</a> *scaling, int32 dstDepth, int32 *sourceLevel, <a class="el" href="struct_v_rect.html">VRect</a> *sourceRect, <a class="el" href="struct_v_rect.html">VRect</a> *sourceScalingBounds)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Determines what level would be used for a given scaling.  <a href="#8351f58591537a4ddc95dc81a5c0b771"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#0fd3d5a2e7e628147452c3893f870b53">New</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> *port, const <a class="el" href="struct_v_rect.html">VRect</a> *rect, int32 depth, Boolean globalScope)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Creates a pixel array and the port to go with it.  <a href="#0fd3d5a2e7e628147452c3893f870b53"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">SPAPI SPErr(*&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_p_s_channel_ports_suite1.html#b0825572d9f52be898206f2756b0b4a4">Dispose</a> )(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> *port)</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Disposes of a port and sets the port to NULL.  <a href="#b0825572d9f52be898206f2756b0b4a4"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The set of routines available in the Channel Ports Suite. 
<p>
<hr><h2>Field Documentation</h2>
<a class="anchor" name="eae2b1855bce31f672578850e0073ec9"></a><!-- doxytag: member="PSChannelPortsSuite1::CountLevels" ref="eae2b1855bce31f672578850e0073ec9" args=")(PIChannelPort port, int32 *count)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#eae2b1855bce31f672578850e0073ec9">PSChannelPortsSuite1::CountLevels</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 *count)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines the number levels the port has. 
<p>
This is the number of levels in the pyramid of an image. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>count</em>&nbsp;</td><td>[OUT] The number of levels the port has. Zero if port is invalid. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="76391d8f9d248932f3e6502547d93283"></a><!-- doxytag: member="PSChannelPortsSuite1::GetDepth" ref="76391d8f9d248932f3e6502547d93283" args=")(PIChannelPort port, int32 level, int32 *depth)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#76391d8f9d248932f3e6502547d93283">PSChannelPortsSuite1::GetDepth</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, int32 *depth)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the pixel depth at a given level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Level of the port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>[OUT] Pixel depth, returned. Zero if the port or level is invalid. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8c59ec11ad199dab11e9e9a20755b824"></a><!-- doxytag: member="PSChannelPortsSuite1::GetDataBounds" ref="8c59ec11ad199dab11e9e9a20755b824" args=")(PIChannelPort port, int32 level, VRect *bounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#8c59ec11ad199dab11e9e9a20755b824">PSChannelPortsSuite1::GetDataBounds</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, <a class="el" href="struct_v_rect.html">VRect</a> *bounds)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the bounds for the pixel data at a given level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Level of the port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bounds</em>&nbsp;</td><td>[OUT] Rectangle that provides the bounds for the pixel data. An empty rectangle if the parameters are invalid. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d3e94d1df452fa96c0e24e3385766a0d"></a><!-- doxytag: member="PSChannelPortsSuite1::GetWriteLimit" ref="d3e94d1df452fa96c0e24e3385766a0d" args=")(PIChannelPort port, int32 level, VRect *writeBounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#d3e94d1df452fa96c0e24e3385766a0d">PSChannelPortsSuite1::GetWriteLimit</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, <a class="el" href="struct_v_rect.html">VRect</a> *writeBounds)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the bounds to which we can write at a given level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Level of the port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writeBounds</em>&nbsp;</td><td>[OUT] Rectangle that provides the write bounds for the pixel data. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8f6080d2425a78828a100ea6f4ce4442"></a><!-- doxytag: member="PSChannelPortsSuite1::GetTilingGrid" ref="8f6080d2425a78828a100ea6f4ce4442" args=")(PIChannelPort port, int32 level, VPoint *tileOrigin, VPoint *tileSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#8f6080d2425a78828a100ea6f4ce4442">PSChannelPortsSuite1::GetTilingGrid</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, <a class="el" href="struct_v_point.html">VPoint</a> *tileOrigin, <a class="el" href="struct_v_point.html">VPoint</a> *tileSize)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the tiling information at a given level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Level of the port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tileOrigin</em>&nbsp;</td><td>[OUT] Origin point for the tiling system. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>tileSize</em>&nbsp;</td><td>[OUT] Size of the tiles. This is the best size to work with, if possible. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4f071d68dc7b36908af4c8e80adee487"></a><!-- doxytag: member="PSChannelPortsSuite1::GetSupportRect" ref="4f071d68dc7b36908af4c8e80adee487" args=")(PIChannelPort port, int32 level, const VRect *bounds, int32 *supportLevel, VRect *supportBounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#4f071d68dc7b36908af4c8e80adee487">PSChannelPortsSuite1::GetSupportRect</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, const <a class="el" href="struct_v_rect.html">VRect</a> *bounds, int32 *supportLevel, <a class="el" href="struct_v_rect.html">VRect</a> *supportBounds)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Finds the rectangle used as the downsample source for a particular level in the pyramid. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Level of the port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bounds</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>supportLevel</em>&nbsp;</td><td>[OUT] Set to -1 if no support rectangle exists. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>supportBounds</em>&nbsp;</td><td>[OUT] Support rectangle, returned. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="ab47ec066e6c007b7c3487c347e37896"></a><!-- doxytag: member="PSChannelPortsSuite1::GetDependentRect" ref="ab47ec066e6c007b7c3487c347e37896" args=")(PIChannelPort port, int32 sourceLevel, const VRect *sourceBounds, int32 dependentLevel, VRect *dependentBounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#ab47ec066e6c007b7c3487c347e37896">PSChannelPortsSuite1::GetDependentRect</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 sourceLevel, const <a class="el" href="struct_v_rect.html">VRect</a> *sourceBounds, int32 dependentLevel, <a class="el" href="struct_v_rect.html">VRect</a> *dependentBounds)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Gets the dependent rectangle at a particular level. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLevel</em>&nbsp;</td><td>Level of the port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceBounds</em>&nbsp;</td><td>[OUT] </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dependentLevel</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dependentBounds</em>&nbsp;</td><td>[OUT] Dependent rectangle, returned. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b8a938423b8e1e901d864e709f85f9a3"></a><!-- doxytag: member="PSChannelPortsSuite1::CanRead" ref="b8a938423b8e1e901d864e709f85f9a3" args=")(PIChannelPort port, Boolean *canRead)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#b8a938423b8e1e901d864e709f85f9a3">PSChannelPortsSuite1::CanRead</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, Boolean *canRead)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if the plug-in can read from the port. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>canRead</em>&nbsp;</td><td>[OUT] Indicates if the plug-in can read from the port; TRUE if so. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="41882dab359c78bf51a5a9a0105b4c68"></a><!-- doxytag: member="PSChannelPortsSuite1::CanWrite" ref="41882dab359c78bf51a5a9a0105b4c68" args=")(PIChannelPort port, Boolean *canWrite)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#41882dab359c78bf51a5a9a0105b4c68">PSChannelPortsSuite1::CanWrite</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, Boolean *canWrite)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines if the plug-in can write to the port. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to check. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>canRead</em>&nbsp;</td><td>[OUT] Indicates if the plug-in can write to the port; TRUE if so. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="14b738488fe314ac3001251e40a3f8f5"></a><!-- doxytag: member="PSChannelPortsSuite1::ReadPixelsFromLevel" ref="14b738488fe314ac3001251e40a3f8f5" args=")(PIChannelPort port, int32 level, VRect *bounds, const PixelMemoryDesc *destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#14b738488fe314ac3001251e40a3f8f5">PSChannelPortsSuite1::ReadPixelsFromLevel</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, int32 level, <a class="el" href="struct_v_rect.html">VRect</a> *bounds,const <a class="el" href="struct_pixel_memory_desc.html">PixelMemoryDesc</a> *destination)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a given rectangle (tile) of pixels from a given level of the port. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>level</em>&nbsp;</td><td>Level of the port. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bounds</em>&nbsp;</td><td>[IN/OUT] Provides the rectangular area (tile) of the port to read as an input parameter. Provides the rectangular area (tile) of data actually read into <code>destination.data</code> as an output parameter, if <code>result</code> is <code>noErr</code>. If <code>result</code> is non-zero, the value is undefined. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>[IN/OUT] A description of the memory to read, provided as input. The data read from the port is written into the buffer provided in <code>destination.data</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="c91b7ae935aae2c75ef817ad5d0b8589"></a><!-- doxytag: member="PSChannelPortsSuite1::WritePixelsToBaseLevel" ref="c91b7ae935aae2c75ef817ad5d0b8589" args=")(PIChannelPort port, VRect *bounds, const PixelMemoryDesc *source)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#c91b7ae935aae2c75ef817ad5d0b8589">PSChannelPortsSuite1::WritePixelsToBaseLevel</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, <a class="el" href="struct_v_rect.html">VRect</a> *bounds,const <a class="el" href="struct_pixel_memory_desc.html">PixelMemoryDesc</a> *source)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes a rectangle (tile) of pixels to a level in the pyramid. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bounds</em>&nbsp;</td><td>[IN/OUT] As input, provides the rectangular area (tile) of <code>source.data</code> the pixels are written from. As output, reflects the area of the port actually written to. If the input rectangle maps to pixels beyond the bounds of the port, the output rectangle reflects the area actually written. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>source</em>&nbsp;</td><td>A description of the memory to write. The actual pixels that are written to the port are provided in <code>source.data</code>. [??? no existing doc. verify. This appears to be an input only parameter for this function, verify.] </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4998f7a5db9c601c29c3e9322be082b1"></a><!-- doxytag: member="PSChannelPortsSuite1::ReadScaledPixels" ref="4998f7a5db9c601c29c3e9322be082b1" args=")(PIChannelPort port, VRect *readRect, const PSScaling *scaling, const PixelMemoryDesc *destination)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#4998f7a5db9c601c29c3e9322be082b1">PSChannelPortsSuite1::ReadScaledPixels</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, <a class="el" href="struct_v_rect.html">VRect</a> *readRect,const <a class="el" href="struct_p_s_scaling.html">PSScaling</a> *scaling, const <a class="el" href="struct_pixel_memory_desc.html">PixelMemoryDesc</a> *destination)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads a given rectangle (tile) of scaled data from the pyramid provided in the port. 
<p>
To determine what level is used for a given scaling, use <code>FindSourceForScaledRead</code>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readRect</em>&nbsp;</td><td>[IN/OUT] Provides the rectangular area (tile) of the port to read as an input parameter. Provides the rectangular area (tile) of data actually read as an output parameter. The output rectangle is scaled based on the information provided in <code>scaling</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scaling</em>&nbsp;</td><td>A scaling between source and destination rectangles. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destination</em>&nbsp;</td><td>[IN/OUT] A description of the memory to read, provided as input. The data read from the port is written into <code>destination.data</code>. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8351f58591537a4ddc95dc81a5c0b771"></a><!-- doxytag: member="PSChannelPortsSuite1::FindSourceForScaledRead" ref="8351f58591537a4ddc95dc81a5c0b771" args=")(PIChannelPort port, const VRect *readRect, const PSScaling *scaling, int32 dstDepth, int32 *sourceLevel, VRect *sourceRect, VRect *sourceScalingBounds)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#8351f58591537a4ddc95dc81a5c0b771">PSChannelPortsSuite1::FindSourceForScaledRead</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, const <a class="el" href="struct_v_rect.html">VRect</a> *readRect, const <a class="el" href="struct_p_s_scaling.html">PSScaling</a> *scaling, int32 dstDepth, int32 *sourceLevel, <a class="el" href="struct_v_rect.html">VRect</a> *sourceRect, <a class="el" href="struct_v_rect.html">VRect</a> *sourceScalingBounds)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Determines what level would be used for a given scaling. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Port to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>readRect</em>&nbsp;</td><td>[IN/OUT] Provides the rectangular area of the port to read as an input parameter. Provides the rectangular area of data actually read as an output parameter. The output rectangle is scaled based on the information provided in <code>scaling</code>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scaling</em>&nbsp;</td><td>A scaling between source and destination rectangles for which to find the pyramid level. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>dstDepth</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceLevel</em>&nbsp;</td><td>[OUT] The level that would be read from for this scaling. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceRect</em>&nbsp;</td><td>[OUT] The rectangle that would be read from for this scaling. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourceScalingBounds</em>&nbsp;</td><td>[OUT] The bounds used for scaling from this level to the final result. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0fd3d5a2e7e628147452c3893f870b53"></a><!-- doxytag: member="PSChannelPortsSuite1::New" ref="0fd3d5a2e7e628147452c3893f870b53" args=")(PIChannelPort *port, const VRect *rect, int32 depth, Boolean globalScope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#0fd3d5a2e7e628147452c3893f870b53">PSChannelPortsSuite1::New</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> *port, const <a class="el" href="struct_v_rect.html">VRect</a> *rect, int32 depth, Boolean globalScope)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Creates a pixel array and the port to go with it. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>Returned port. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>The rectangle used to create a pixel array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>depth</em>&nbsp;</td><td>The pixel depth for the pixel array. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>globalScope</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b0825572d9f52be898206f2756b0b4a4"></a><!-- doxytag: member="PSChannelPortsSuite1::Dispose" ref="b0825572d9f52be898206f2756b0b4a4" args=")(PIChannelPort *port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(*  <a class="el" href="struct_p_s_channel_ports_suite1.html#b0825572d9f52be898206f2756b0b4a4">PSChannelPortsSuite1::Dispose</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> *port)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disposes of a port and sets the port to NULL. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port to dispose of. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a2695c34be6f74979a7433652eab22a1"></a><!-- doxytag: member="PSChannelPortsSuite1::SupportsOperation" ref="a2695c34be6f74979a7433652eab22a1" args=")(const char *operation, Boolean *supported)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#a2695c34be6f74979a7433652eab22a1">PSChannelPortsSuite1::SupportsOperation</a>)(const char *operation, Boolean *supported)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks to see whether the host supports an operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>The operation to check. See <a class="el" href="group___channel_port_operations.html">Channel Port Operations</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>supported</em>&nbsp;</td><td>[OUT] Indicates whether the operation is supported; TRUE if so. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ed075af1f71d83a5253437ae7acfe0f"></a><!-- doxytag: member="PSChannelPortsSuite1::ApplyOperation" ref="7ed075af1f71d83a5253437ae7acfe0f" args=")(const char *operation, PIChannelPort sourcePort, PIChannelPort destinationPort, PIChannelPort maskPort, void *parameters, VRect *rect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#7ed075af1f71d83a5253437ae7acfe0f">PSChannelPortsSuite1::ApplyOperation</a>)(const char *operation, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> sourcePort, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> destinationPort, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> maskPort, void *parameters,<a class="el" href="struct_v_rect.html">VRect</a> *rect)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies an operation from a source port to a destination port. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>The operation to apply. See <a class="el" href="group___channel_port_operations.html">Channel Port Operations</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourcePort</em>&nbsp;</td><td>The source port to apply an operation from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destinationPort</em>&nbsp;</td><td>The destination port to write the results of the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maskPort</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parameters</em>&nbsp;</td><td>A structure that provides the parameters for the operation. The structure depends on the operation. See <a class="el" href="group___channel_port_operations.html">Channel Port Operations</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>[IN/OUT] A bounding rectangle; may also be an output parameter, depending on the operation. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e4c99d47b6a03357d56a86cf2805acb"></a><!-- doxytag: member="PSChannelPortsSuite1::AddOperation" ref="4e4c99d47b6a03357d56a86cf2805acb" args=")(const char *operation, SPErr(*proc)(PIChannelPort, PIChannelPort, PIChannelPort, void *, VRect *, void *refCon), void *refCon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#4e4c99d47b6a03357d56a86cf2805acb">PSChannelPortsSuite1::AddOperation</a>)(const char *operation, SPErr(*proc)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a>, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a>, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a>,void *, <a class="el" href="struct_v_rect.html">VRect</a> *, void *refCon), void *refCon)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a channel port operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>The name of the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The routine to execute when this operation is invoked. The first three parameters indicate source, destination and mask ports, respectively. The fifth parameter is a bounding rectangle, and the sixth is a structure used to pass parameters to the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCon</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f6e24878d8f1dd2200ee1b60e37eb64b"></a><!-- doxytag: member="PSChannelPortsSuite1::RemoveOperation" ref="f6e24878d8f1dd2200ee1b60e37eb64b" args=")(const char *operation, void **refCon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#f6e24878d8f1dd2200ee1b60e37eb64b">PSChannelPortsSuite1::RemoveOperation</a>)(const char *operation, void **refCon)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a channel port operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>The name of the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCon</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a201d8f8a17bcc334fef18ab922de89d"></a><!-- doxytag: member="PSChannelPortsSuite1::NewCopyOnWrite" ref="a201d8f8a17bcc334fef18ab922de89d" args=")(PIChannelPort *result, PIChannelPort basePort, VRect *writeLimit, Boolean globalScope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#a201d8f8a17bcc334fef18ab922de89d">PSChannelPortsSuite1::NewCopyOnWrite</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> *result, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> basePort, <a class="el" href="struct_v_rect.html">VRect</a> *writeLimit, Boolean globalScope)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Supports using the copy-on-write mechanism. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>[OUT] The destination port, returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>basePort</em>&nbsp;</td><td>The base port; must be frozen. See <a class="el" href="struct_p_s_channel_ports_suite1.html#d73aba2b1661ebd882f97e41ace5038a">Freeze</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writeLimit</em>&nbsp;</td><td>[OUT] Defines a rectangle that limits the scope of the write. Can be NULL in which case writing is allowed everywhere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>globalScope</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d73aba2b1661ebd882f97e41ace5038a"></a><!-- doxytag: member="PSChannelPortsSuite1::Freeze" ref="d73aba2b1661ebd882f97e41ace5038a" args=")(PIChannelPort port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#d73aba2b1661ebd882f97e41ace5038a">PSChannelPortsSuite1::Freeze</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Freezes the data associated with a channel port. 
<p>
This should generally only be used in conjunction with ports allocated through <code>NewCopyOnWrite</code>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port to freeze. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a9331e5056398b46dabd37816a88143b"></a><!-- doxytag: member="PSChannelPortsSuite1::Restore" ref="a9331e5056398b46dabd37816a88143b" args=")(PIChannelPort port, VRect *area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#a9331e5056398b46dabd37816a88143b">PSChannelPortsSuite1::Restore</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, <a class="el" href="struct_v_rect.html">VRect</a> *area)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restores an <code>area</code> within a copy-on-write port to its initial state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port to restore. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>area.</em>&nbsp;</td><td>The area to restore. If NULL, the entire port is restored. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a2695c34be6f74979a7433652eab22a1"></a><!-- doxytag: member="PSChannelPortsSuite1::SupportsOperation" ref="a2695c34be6f74979a7433652eab22a1" args=")(const char *operation, Boolean *supported)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#a2695c34be6f74979a7433652eab22a1">PSChannelPortsSuite1::SupportsOperation</a>)(const char *operation, Boolean *supported)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Checks to see whether the host supports an operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>The operation to check. See <a class="el" href="group___channel_port_operations.html">Channel Port Operations</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>supported</em>&nbsp;</td><td>[OUT] Indicates whether the operation is supported; TRUE if so. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7ed075af1f71d83a5253437ae7acfe0f"></a><!-- doxytag: member="PSChannelPortsSuite1::ApplyOperation" ref="7ed075af1f71d83a5253437ae7acfe0f" args=")(const char *operation, PIChannelPort sourcePort, PIChannelPort destinationPort, PIChannelPort maskPort, void *parameters, VRect *rect)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#7ed075af1f71d83a5253437ae7acfe0f">PSChannelPortsSuite1::ApplyOperation</a>)(const char *operation, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> sourcePort, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> destinationPort, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> maskPort, void *parameters,<a class="el" href="struct_v_rect.html">VRect</a> *rect)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Applies an operation from a source port to a destination port. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>The operation to apply. See <a class="el" href="group___channel_port_operations.html">Channel Port Operations</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>sourcePort</em>&nbsp;</td><td>The source port to apply an operation from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>destinationPort</em>&nbsp;</td><td>The destination port to write the results of the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>maskPort</em>&nbsp;</td><td></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>parameters</em>&nbsp;</td><td>A structure that provides the parameters for the operation. The structure depends on the operation. See <a class="el" href="group___channel_port_operations.html">Channel Port Operations</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>rect</em>&nbsp;</td><td>[IN/OUT] A bounding rectangle; may also be an output parameter, depending on the operation. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e4c99d47b6a03357d56a86cf2805acb"></a><!-- doxytag: member="PSChannelPortsSuite1::AddOperation" ref="4e4c99d47b6a03357d56a86cf2805acb" args=")(const char *operation, SPErr(*proc)(PIChannelPort, PIChannelPort, PIChannelPort, void *, VRect *, void *refCon), void *refCon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#4e4c99d47b6a03357d56a86cf2805acb">PSChannelPortsSuite1::AddOperation</a>)(const char *operation, SPErr(*proc)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a>, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a>, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a>,void *, <a class="el" href="struct_v_rect.html">VRect</a> *, void *refCon), void *refCon)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Adds a channel port operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>The name of the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>proc</em>&nbsp;</td><td>The routine to execute when this operation is invoked. The first three parameters indicate source, destination and mask ports, respectively. The fifth parameter is a bounding rectangle, and the sixth is a structure used to pass parameters to the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCon</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f6e24878d8f1dd2200ee1b60e37eb64b"></a><!-- doxytag: member="PSChannelPortsSuite1::RemoveOperation" ref="f6e24878d8f1dd2200ee1b60e37eb64b" args=")(const char *operation, void **refCon)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#f6e24878d8f1dd2200ee1b60e37eb64b">PSChannelPortsSuite1::RemoveOperation</a>)(const char *operation, void **refCon)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Removes a channel port operation. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>operation</em>&nbsp;</td><td>The name of the operation. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>refCon</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a201d8f8a17bcc334fef18ab922de89d"></a><!-- doxytag: member="PSChannelPortsSuite1::NewCopyOnWrite" ref="a201d8f8a17bcc334fef18ab922de89d" args=")(PIChannelPort *result, PIChannelPort basePort, VRect *writeLimit, Boolean globalScope)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#a201d8f8a17bcc334fef18ab922de89d">PSChannelPortsSuite1::NewCopyOnWrite</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> *result, <a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> basePort, <a class="el" href="struct_v_rect.html">VRect</a> *writeLimit, Boolean globalScope)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Supports using the copy-on-write mechanism. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>result</em>&nbsp;</td><td>[OUT] The destination port, returned. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>basePort</em>&nbsp;</td><td>The base port; must be frozen. See <a class="el" href="struct_p_s_channel_ports_suite1.html#d73aba2b1661ebd882f97e41ace5038a">Freeze</a>. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>writeLimit</em>&nbsp;</td><td>[OUT] Defines a rectangle that limits the scope of the write. Can be NULL in which case writing is allowed everywhere. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>globalScope</em>&nbsp;</td><td></td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d73aba2b1661ebd882f97e41ace5038a"></a><!-- doxytag: member="PSChannelPortsSuite1::Freeze" ref="d73aba2b1661ebd882f97e41ace5038a" args=")(PIChannelPort port)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#d73aba2b1661ebd882f97e41ace5038a">PSChannelPortsSuite1::Freeze</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Freezes the data associated with a channel port. 
<p>
This should generally only be used in conjunction with ports allocated through <code>NewCopyOnWrite</code>. <dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port to freeze. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a9331e5056398b46dabd37816a88143b"></a><!-- doxytag: member="PSChannelPortsSuite1::Restore" ref="a9331e5056398b46dabd37816a88143b" args=")(PIChannelPort port, VRect *area)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SPAPI SPErr(* <a class="el" href="struct_p_s_channel_ports_suite1.html#a9331e5056398b46dabd37816a88143b">PSChannelPortsSuite1::Restore</a>)(<a class="el" href="group___channel_ports_suite.html#gfca6f81c41ebe5a82af5555a7183cfd3">PIChannelPort</a> port, <a class="el" href="struct_v_rect.html">VRect</a> *area)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Restores an <code>area</code> within a copy-on-write port to its initial state. 
<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>port</em>&nbsp;</td><td>The port to restore. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>area.</em>&nbsp;</td><td>The area to restore. If NULL, the entire port is restored. </td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Non-zero error if failure. </dd></dl>

</div>
</div><p>
<hr>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="_p_i_channel_ports_suite_8h-source.html">PIChannelPortsSuite.h</a></ul>

<!-- Begin Footer -->
</td>
<td width="20">&nbsp;&nbsp;</td>
</table>

<div id="footerrow"><!--give footer 25px of white above--></div>
<div id="footer" title="footer: links to copyright and other legal information">
<p><a href="licenses.html" class="el">&copy; 2016 Adobe Systems Incorporated</a></p>
<a title="Terms of Use" href="http://www.adobe.com/misc/copyright.html">Terms of Use - </a>
<a title="Privacy Policy" href="http://www.adobe.com/misc/privacy.html">Privacy Policy - </a>
<a href="http://access.adobe.com">Accessibility - </a>
<a title="Avoid software piracy" href="http://www.adobe.com/aboutadobe/antipiracy/main.html">Avoid software piracy - </a>
<a title="Permissions and trademarks" href="http://www.adobe.com/misc/agreement.html">Permissions and trademarks - </a>
<a title="Product License Agreements" href="http://www.adobe.com/products/eulas/main.html">Product License Agreements</a></div>
<p/>
</body>
</html>
